.TH "create" 3 "Wed Sep 4 2024" "Version 1.0.0" "libkipr" \" -*- nroff -*-
.ad l
.nh
.SH NAME
create \- iRobot (R) Create (TM)
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBkipr::create::CreateScript\fP"
.br
.ti -1c
.RI "class \fBkipr::create::Create\fP"
.br
.RI "Facilitates communication with the iRobot (R) \fBCreate\fP (TM) "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBcreate_connect\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBcreate_connect_once\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBcreate_disconnect\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBcreate_passive\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBcreate_safe\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBcreate_full\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_mode\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_lbump\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_rbump\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_lwdrop\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_cwdrop\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_rwdrop\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_wall\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_lcliff\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_lfcliff\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_rfcliff\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_rcliff\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_llightbump\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_lflightbump\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_lclightbump\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_rclightbump\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_rflightbump\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_rlightbump\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_llightbump_amt\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_rlightbump_amt\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_lflightbump_amt\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_lclightbump_amt\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_rclightbump_amt\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_rflightbump_amt\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_vwall\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_infrared\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_advance_button\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_play_button\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_normalized_angle\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBset_create_normalized_angle\fP (int angle)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_total_angle\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBset_create_total_angle\fP (int angle)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_distance\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBset_create_distance\fP (int dist)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_battery_charging_state\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_battery_temp\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_battery_charge\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_battery_capacity\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_wall_amt\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_lcliff_amt\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_lfcliff_amt\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_rfcliff_amt\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_rcliff_amt\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_song_number\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBget_create_song_playing\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBcreate_stop\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBcreate_drive\fP (int speed, int radius)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBcreate_drive_straight\fP (int speed)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBcreate_spin_CW\fP (int speed)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBcreate_spin_CCW\fP (int speed)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBcreate_drive_direct\fP (int l_speed, int r_speed)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBcreate_spin_block\fP (int speed, int angle)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fB_create_get_raw_encoders\fP (long *lenc, long *renc)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBcreate_load_song\fP (const unsigned char *song, const unsigned char length, const unsigned char num)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBcreate_play_song\fP (const unsigned char num)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP int \fBcreate_read_block\fP (char *data, int count)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBcreate_write_byte\fP (char byte)"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBcreate_clear_serial_buffer\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP enum \fBBaudRate\fP \fBget_create_baud_rate\fP ()"
.br
.ti -1c
.RI "\fBEXPORT_SYM\fP void \fBset_create_baud_rate\fP (const enum \fBBaudRate\fP baudRate)"
.br
.ti -1c
.RI "bool \fBkipr::create::Create::loadSong\fP (const unsigned char *song, const unsigned char length, const unsigned char songNum)"
.br
.ti -1c
.RI "bool \fBkipr::create::Create::playSong\fP (const unsigned char songNum)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The functions here allow for communication with the Create (roomba)\&. They only work when there is a Create cable plugged into the wombat and into the Create\&. 
.SH "Setup"
.PP
Make sure to plug the usb side of the Create cable into the wombat and the other side into the Create\&. 
.SH "Movement Example"
.PP
Once you've done that, you can now use the roomba\&. The following example moves the roomba forward, swerves left, swerves right, and finally drives backwards\&. 
.PP
.nf
#include <kipr/wombat\&.h>
#include <stdio\&.h>

int main(){
     // connect to the create in order to control it
     create_connect_once();

     // move forward for 1 second
     create_drive_direct(200, 200);
     msleep(1000);

     // swerve left
     create_drive_direct(100, 200);
     msleep(300);
     // swerve right
     create_drive_direct(200, 100);
     msleep(300);
 
     // go backwards for 1 second
     create_drive_direct(-100, -100);
     msleep(1000);

     // stop moving
     create_drive_direct(0, 0);

     // disconnect before ending the program
     create_disconnect();
     return 0;
}

.fi
.PP
 
.SH "Function Documentation"
.PP 
.SS "\fBEXPORT_SYM\fP int _create_get_raw_encoders (long * lenc, long * renc)"
Gets the displacement of the left wheel and right wheel and puts that data into the \fClong\fPs provided 
.PP
\fBParameters\fP
.RS 4
\fIlenc\fP - where the left wheel's displacement is stored 
.br
\fIrenc\fP - where the right wheel's displacement is stored 
.RE
.PP
\fBNote\fP
.RS 4
Not yet implemented 
.RE
.PP

.SS "\fBEXPORT_SYM\fP void create_clear_serial_buffer ()"
Flushes commands to the create\&. 
.PP
\fBNote\fP
.RS 4
This library already automatically flushes commands to the create 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int create_connect ()"
Waits to establish a connection to the create\&. 
.PP
\fB\fBThis\fP function blocks until A connection to a create is established\fP
.RS 4

.RE
.PP
\fBReturns\fP
.RS 4
0 on success 
.RE
.PP
\fBSee also\fP
.RS 4
\fBcreate_disconnect\fP 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int create_connect_once ()"
Attempts to establish a connection to the create\&. 
.PP
\fBReturns\fP
.RS 4
1 if connection succeeded, 0 if connection failed 
.RE
.PP
\fBSee also\fP
.RS 4
\fBcreate_disconnect\fP 
.RE
.PP

.SS "\fBEXPORT_SYM\fP void create_disconnect ()"
Disconnects the controller from the iRobot Create\&.
.PP
ALWAYS disconnect from the iRobot Create before ending your program\&. 
.PP
\fBSee also\fP
.RS 4
\fBcreate_connect\fP 
.RE
.PP

.SS "\fBEXPORT_SYM\fP void create_drive (int speed, int radius)"
Drive at the requested speed in an arc with the provided radius\&. 
.PP
\fBParameters\fP
.RS 4
\fIspeed\fP The speed (in mm/s) to drive at\&. Range is -500 to 500\&. 
.br
\fIradius\fP The radius (in mm) of the arc to drive through\&. Range is -2000 to 2000\&. 
.RE
.PP

.SS "\fBEXPORT_SYM\fP void create_drive_direct (int l_speed, int r_speed)"
Drive the create at the provided left wheel speed and right wheel speed\&. 
.PP
\fBParameters\fP
.RS 4
\fIl_speed\fP The speed (in mm/s) to drive the left wheel at\&. Range is -500 to 500 
.br
\fIr_speed\fP The speed (in mm/s) to drive the right wheel at\&. Range is -500 to 500 
.RE
.PP

.SS "\fBEXPORT_SYM\fP void create_drive_straight (int speed)"
Drive straight at the requested speed\&. 
.PP
\fBParameters\fP
.RS 4
\fIspeed\fP The speed (in mm/s) to drive at\&. Range is -500 to 500\&. 
.RE
.PP

.SS "\fBEXPORT_SYM\fP void create_full ()"

.PP
\fBSee also\fP
.RS 4
\fBcreate_safe\fP 
.PP
\fBcreate_passive\fP 
.PP
\fBget_create_mode\fP
.RE
.PP
Puts the iRobot Create in 'Full Mode'
.PP
'Full Mode' allows the programmer to completely control all functions of the Create (disables safety blocks)\&.
.PP
With this mode enabled, the Create will not prevent use of motors in situations where it detects an edge/cliff/etc\&.
.PP
Use this if you are having issues with the Create not moving after lifting it, falling, etc\&. 
.SS "\fBEXPORT_SYM\fP int create_load_song (const unsigned char * song, const unsigned char length, const unsigned char num)"
Loads a song for playing on the create 
.PP
\fBParameters\fP
.RS 4
\fIsong\fP It should be an array of unsigned chars (positive integers 0-255) The first value in a pair will be the midi value of the note the second value in the pair will be the duration (in 64ths of a second) for example, a song {88, 20, 91, 32, 70, 15} will play midi value 88 for 20/64ths of a second, midi value 91 for 32/64ths of a second, and midi value 70 for 15/64ths of a second\&. A full list of notes playable on the create is found at https://cdn-shop.adafruit.com/datasheets/create_2_Open_Interface_Spec.pdf on page 34 
.br
 
.br
\fIlength\fP The length of the song\&. It is how many notes are in the song, not how many items are in your song array\&. 
.br
\fInum\fP The song slot to load the song into; valid values are 0, 1, 2, and 3 
.RE
.PP
\fBReturns\fP
.RS 4
1 on success, 0 on failure 
.RE
.PP
\fBNote\fP
.RS 4
Example use: \fCunsigned char example_song[] = {88, 20, 91, 32, 70, 15}; create_load_song(example_song, 3, 0);\fP 
.RE
.PP

.SS "\fBEXPORT_SYM\fP void create_passive ()"

.PP
\fBSee also\fP
.RS 4
\fBcreate_safe\fP 
.PP
\fBcreate_full\fP 
.PP
\fBget_create_mode\fP
.RE
.PP
When the Create is in Passive mode, you can request and receive sensor data using any of the sensor commands,
.PP
but you cannot change the current command parameters for the actuators (motors, speaker, lights, low side drivers, digital outputs) to something else\&.
.PP
To change how one of the actuators operates, you must switch from Passive mode to Full mode or Safe mode\&.
.PP
While in Passive mode, you can read Roomba’s sensors, watch Roomba perform a cleaning cycle, and charge the battery\&.
.PP
In Passive mode, Roomba will go into power saving mode to conserve battery power after five minutes of inactivity 
.PP
\fBNote\fP
.RS 4
Appears to crash controller, do not use or use serial communication\&. 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int create_play_song (const unsigned char num)"
Plays a song that has been loaded\&. Use create_load_song first\&. 
.PP
\fBParameters\fP
.RS 4
\fInum\fP The song slot to play from; valid values are 0, 1, 2, and 3 
.RE
.PP
\fBReturns\fP
.RS 4
1 on success, 0 on failure 
.RE
.PP
\fBSee also\fP
.RS 4
\fBcreate_load_song\fP 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int create_read_block (char * data, int count)"
Reads sensor data from the create\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP - This is where the read sensor data is stored 
.br
\fIcount\fP - How many bytes to read from the create\&. 
.RE
.PP
\fBReturns\fP
.RS 4
1 on success, 0 on failure\&. 
.RE
.PP

.SS "\fBEXPORT_SYM\fP void create_safe ()"

.PP
\fBSee also\fP
.RS 4
\fBcreate_full\fP 
.PP
\fBcreate_passive\fP 
.PP
\fBget_create_mode\fP
.RE
.PP
Puts the iRobot Create in 'Safe Mode'
.PP
Safe mode gives you full control of Roomba, with the exception of the following safety-related conditions\&.
.PP
safety-related conditions include: Cliff detection, wheel drop, and charging\&.
.PP
If your Create is refusing to move, try setting it to full mode\&. 
.SS "\fBEXPORT_SYM\fP void create_spin_block (int speed, int angle)"
Turns the create the requested number of degrees at the requested speed\&. 
.PP
\fBParameters\fP
.RS 4
\fIspeed\fP The speed (in mm/s) to turn at\&. Range is -500 to 500 
.br
\fIangle\fP The angle (in degrees) to turn\&. 
.RE
.PP
\fBNote\fP
.RS 4
This is a blocking function, so you DO NOT need an msleep after it\&. It already sleeps for the time that it needs to execute the turn and doesn't need extra msleeps\&. 
.RE
.PP

.SS "\fBEXPORT_SYM\fP void create_spin_CCW (int speed)"
Spin counter-clockwise at the requested speed\&. Spins in place\&. 
.PP
\fBParameters\fP
.RS 4
\fIspeed\fP The speed (in mm/s) to drive at\&. Range is -500 to 500\&. 
.RE
.PP
\fBNote\fP
.RS 4
negative speeds will result in spinning clockwise 
.RE
.PP

.SS "\fBEXPORT_SYM\fP void create_spin_CW (int speed)"
Spin clockwise at the requested speed\&. Spins in place\&. 
.PP
\fBParameters\fP
.RS 4
\fIspeed\fP The speed (in mm/s) to drive at\&. Range is -500 to 500\&. 
.RE
.PP
\fBNote\fP
.RS 4
negative speeds will result in spinning counter-clockwise 
.RE
.PP

.SS "\fBEXPORT_SYM\fP void create_stop ()"
Sets the create connection mode to off\&. No sensor data will be available, and the create will not respond to movement commands\&. 
.SS "\fBEXPORT_SYM\fP void create_write_byte (char byte)"
Write a byte to the create\&. This is used to send commands directly to the create without using the functions provided in this library\&. 
.PP
\fBNote\fP
.RS 4
If you want to directly send bytes to the create, consider checking out the actual create oi specifications: https://cdn-shop.adafruit.com/datasheets/create_2_Open_Interface_Spec.pdf 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int get_create_advance_button ()"
Returns if the 'advance' button is pressed\&. 
.PP
\fBNote\fP
.RS 4
'Advance' is not a button on the newer Creates\&. 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int get_create_battery_capacity ()"
Returns the capacity of the battery in milliAmp-Hours (mAH) 
.SS "\fBEXPORT_SYM\fP int get_create_battery_charge ()"
returns the current charge on the battery in milliAmp-Hours (mAH) 
.SS "\fBEXPORT_SYM\fP int get_create_battery_charging_state ()"

.PP
\fBSee also\fP
.RS 4
get_create_battery_voltage 
.PP
get_create_battery_current
.RE
.PP
returns the current charging state of the battery\&.
.PP
Not Charging: 0, Reconditioning Charging: 1, Full Charging: 2, Trickle Charging: 3, Waiting: 4, Charging Connection Fault: 5 
.SS "\fBEXPORT_SYM\fP int get_create_battery_temp ()"
returns the temperature of the battery in degrees Celcius 
.SS "\fBEXPORT_SYM\fP enum \fBBaudRate\fP get_create_baud_rate ()"
Returns the baud rate of the create\&. 
.PP
\fBNote\fP
.RS 4
The baud rate is how many times a second the create updates its sensors and receives commands\&. 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int get_create_cwdrop ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_rwdrop\fP 
.PP
\fBget_create_lwdrop\fP 
.RE
.PP
\fBNote\fP
.RS 4
Not Implemented 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int get_create_distance ()"

.PP
\fBSee also\fP
.RS 4
\fBset_create_distance\fP
.RE
.PP
Gets the distance traveled based on encoder values in the wheels\&.
.PP
Units should be in millimeters (mm) 
.SS "\fBEXPORT_SYM\fP int get_create_infrared ()"
The Docks, Virutal Walls, etc\&. send out infrared signals that the Create can pick up\&.
.PP
For example, Right of dock ('Green Buoy'): 164, Left of Dock ('Red Buoy'): 168, 'Force Field': 161
.PP
You can also potentially control the Create with IR signals for forward, backward, etc\&.
.PP
See iRobot Create Manual for more information ('Characters sent by iRobot devices') 
.SS "\fBEXPORT_SYM\fP int get_create_lbump ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_rbump\fP
.RE
.PP
Returns the status of the left bumper as a digital value (0 or 1)\&. 
.SS "\fBEXPORT_SYM\fP int get_create_lcliff ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lfcliff\fP 
.PP
\fBget_create_rfcliff\fP 
.PP
\fBget_create_rcliff\fP
.RE
.PP
reports if the left cliff/edge sensor is tripped\&. 
.SS "\fBEXPORT_SYM\fP int get_create_lcliff_amt ()"
Returns the value measured by the left-most cliff sensor\&. 
.PP
\fBNote\fP
.RS 4
For line following purposes, this can be treated like a tophat sensor value\&. Lower values often indicate black, higher values often indicate white\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBget_create_lcliff\fP 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int get_create_lclightbump ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lflightbump\fP 
.PP
\fBget_create_llightbump\fP 
.PP
\fBget_create_rclightbump\fP 
.PP
\fBget_create_rflightbump\fP 
.PP
\fBget_create_rlightbump\fP
.RE
.PP
returns the left-center light bumper sensor as described in the iRobot Create manual\&.
.PP
returns a binary/digital value rather than the raw sensor data (on or off/1 or 0)\&. 
.SS "\fBEXPORT_SYM\fP int get_create_lclightbump_amt ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lflightbump_amt\fP 
.PP
\fBget_create_llightbump_amt\fP 
.PP
\fBget_create_rclightbump_amt\fP 
.PP
\fBget_create_rflightbump_amt\fP 
.PP
\fBget_create_rlightbump_amt\fP
.RE
.PP
returns the left-center light bumper sensor as described in the iRobot Create manual\&.
.PP
returns the amount the sensor is pressed, rather than a binary value\&. 
.SS "\fBEXPORT_SYM\fP int get_create_lfcliff ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lcliff\fP 
.PP
\fBget_create_rfcliff\fP 
.PP
\fBget_create_rcliff\fP
.RE
.PP
reports if the front-left cliff/edge sensor is tripped\&. 
.SS "\fBEXPORT_SYM\fP int get_create_lfcliff_amt ()"
Returns the value measured by the left-front cliff sensor\&. 
.PP
\fBNote\fP
.RS 4
For line following purposes, this can be treated like a tophat sensor value\&. Lower values often indicate black, higher values often indicate white\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBget_create_lfcliff\fP 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int get_create_lflightbump ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_llightbump\fP 
.PP
\fBget_create_lclightbump\fP 
.PP
\fBget_create_rclightbump\fP 
.PP
\fBget_create_rflightbump\fP 
.PP
\fBget_create_rlightbump\fP
.RE
.PP
returns the left-front light bumper sensor as described in the iRobot Create manual\&.
.PP
returns a binary/digital value rather than the raw sensor data (on or off/1 or 0)\&. 
.SS "\fBEXPORT_SYM\fP int get_create_lflightbump_amt ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_llightbump_amt\fP 
.PP
\fBget_create_lclightbump_amt\fP 
.PP
\fBget_create_rclightbump_amt\fP 
.PP
\fBget_create_rflightbump_amt\fP 
.PP
\fBget_create_rlightbump_amt\fP
.RE
.PP
returns the left-front light bumper sensor as described in the iRobot Create manual\&.
.PP
returns the amount the sensor is pressed, rather than a binary value\&. 
.SS "\fBEXPORT_SYM\fP int get_create_llightbump ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lflightbump\fP 
.PP
\fBget_create_lclightbump\fP 
.PP
\fBget_create_rclightbump\fP 
.PP
\fBget_create_rflightbump\fP 
.PP
\fBget_create_rlightbump\fP
.RE
.PP
returns the left light bumper sensor as described in the iRobot Create manual\&.
.PP
returns a binary/digital value rather than the raw sensor data (on or off/1 or 0)\&. 
.SS "\fBEXPORT_SYM\fP int get_create_llightbump_amt ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lflightbump_amt\fP 
.PP
\fBget_create_lclightbump_amt\fP 
.PP
\fBget_create_rclightbump_amt\fP 
.PP
\fBget_create_rflightbump_amt\fP 
.PP
\fBget_create_rlightbump_amt\fP
.RE
.PP
returns the left light bumper sensor as described in the iRobot Create manual\&.
.PP
returns the amount the sensor is pressed, rather than a binary value\&. 
.SS "\fBEXPORT_SYM\fP int get_create_lwdrop ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_rwdrop\fP
.RE
.PP
Detects if the left wheel is dropped/lowered (the create is lifted) 
.SS "\fBEXPORT_SYM\fP int get_create_mode ()"

.PP
\fBSee also\fP
.RS 4
\fBcreate_safe\fP 
.PP
\fBcreate_passive\fP 
.PP
\fBcreate_full\fP
.RE
.PP
Gets the current mode of the Create OI
.PP
Off: 0, Passive: 1, Safe: 2, Full: 3 
.SS "\fBEXPORT_SYM\fP int get_create_normalized_angle ()"

.PP
\fBSee also\fP
.RS 4
\fBset_create_normalized_angle\fP
.RE
.PP
returns the normalized angle that the create is at in degrees (angle mod 360)\&.
.PP
'Normalized' means that the angle is converted to be between 0 and 360 degrees first\&. 
.SS "\fBEXPORT_SYM\fP int get_create_play_button ()"
Returns if the 'play' button is pressed\&. 
.PP
\fBNote\fP
.RS 4
'Play' is not a button on the newer Creates\&. 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int get_create_rbump ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lbump\fP
.RE
.PP
Returns the status of the right bumper as a digital value (0 or 1)\&. 
.SS "\fBEXPORT_SYM\fP int get_create_rcliff ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lcliff\fP 
.PP
\fBget_create_lfcliff\fP 
.PP
\fBget_create_rfcliff\fP
.RE
.PP
reports if the right cliff/edge sensor is tripped\&. 
.SS "\fBEXPORT_SYM\fP int get_create_rcliff_amt ()"
Returns the value measured by the right-most cliff sensor\&. 
.PP
\fBNote\fP
.RS 4
For line following purposes, this can be treated like a tophat sensor value\&. Lower values often indicate black, higher values often indicate white\&. 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int get_create_rclightbump ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lflightbump\fP 
.PP
\fBget_create_lclightbump\fP 
.PP
\fBget_create_llightbump\fP 
.PP
\fBget_create_rflightbump\fP 
.PP
\fBget_create_rlightbump\fP
.RE
.PP
returns the right-center light bumper sensor as described in the iRobot Create manual\&.
.PP
returns a binary/digital value rather than the raw sensor data (on or off/1 or 0)\&. 
.SS "\fBEXPORT_SYM\fP int get_create_rclightbump_amt ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lflightbump_amt\fP 
.PP
\fBget_create_lclightbump_amt\fP 
.PP
\fBget_create_llightbump_amt\fP 
.PP
\fBget_create_rflightbump_amt\fP 
.PP
\fBget_create_rlightbump_amt\fP
.RE
.PP
returns the right-center light bumper sensor as described in the iRobot Create manual\&.
.PP
returns the amount the sensor is pressed, rather than a binary value\&. 
.SS "\fBEXPORT_SYM\fP int get_create_rfcliff ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lcliff\fP 
.PP
\fBget_create_rcliff\fP 
.PP
\fBget_create_lfcliff\fP
.RE
.PP
reports if the front-right cliff/edge sensor is tripped\&. 
.SS "\fBEXPORT_SYM\fP int get_create_rfcliff_amt ()"
Returns the value measured by the right-front cliff sensor\&. 
.PP
\fBNote\fP
.RS 4
For line following purposes, this can be treated like a tophat sensor value\&. Lower values often indicate black, higher values often indicate white\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBget_create_rfcliff\fP 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int get_create_rflightbump ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lflightbump\fP 
.PP
\fBget_create_lclightbump\fP 
.PP
\fBget_create_rclightbump\fP 
.PP
\fBget_create_llightbump\fP 
.PP
\fBget_create_rlightbump\fP
.RE
.PP
returns the right-front light bumper sensor as described in the iRobot Create manual\&.
.PP
returns a binary/digital value rather than the raw sensor data (on or off/1 or 0)\&. 
.SS "\fBEXPORT_SYM\fP int get_create_rflightbump_amt ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lflightbump_amt\fP 
.PP
\fBget_create_lclightbump_amt\fP 
.PP
\fBget_create_rclightbump_amt\fP 
.PP
\fBget_create_llightbump_amt\fP 
.PP
\fBget_create_rlightbump_amt\fP
.RE
.PP
returns the right-front light bumper sensor as described in the iRobot Create manual\&.
.PP
returns the amount the sensor is pressed, rather than a binary value\&. 
.SS "\fBEXPORT_SYM\fP int get_create_rlightbump ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lflightbump\fP 
.PP
\fBget_create_lclightbump\fP 
.PP
\fBget_create_rclightbump\fP 
.PP
\fBget_create_rflightbump\fP 
.PP
\fBget_create_llightbump\fP
.RE
.PP
returns the right light bumper sensor as described in the iRobot Create manual\&.
.PP
returns a binary/digital value rather than the raw sensor data (on or off/1 or 0)\&. 
.SS "\fBEXPORT_SYM\fP int get_create_rlightbump_amt ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lflightbump_amt\fP 
.PP
\fBget_create_lclightbump_amt\fP 
.PP
\fBget_create_rclightbump_amt\fP 
.PP
\fBget_create_rflightbump_amt\fP 
.PP
\fBget_create_llightbump_amt\fP
.RE
.PP
returns the right light bumper sensor as described in the iRobot Create manual\&.
.PP
returns the amount the sensor is pressed, rather than a binary value\&. 
.SS "\fBEXPORT_SYM\fP int get_create_rwdrop ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_lwdrop\fP
.RE
.PP
Detects if the right wheel is dropped/lowered (the create is lifted) 
.SS "\fBEXPORT_SYM\fP int get_create_song_number ()"

.PP
\fBReturns\fP
.RS 4
The song slot of the current song 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int get_create_song_playing ()"

.PP
\fBReturns\fP
.RS 4
1 if it the create is playing a song, 0 if the create isn't playing a song 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int get_create_total_angle ()"

.PP
\fBSee also\fP
.RS 4
\fBset_create_total_angle\fP
.RE
.PP
returns the angle the Create is currently turned to (does not 'normalize')\&.
.PP
This value is any value as it is not normalized to a range of [0,360) 
.SS "\fBEXPORT_SYM\fP int get_create_vwall ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_wall\fP
.RE
.PP
Reports if there is a virutal wall\&. 
.PP
\fBNote\fP
.RS 4
The botball kit does not contain a 'virtual wall' unit as of Fall 2019\&. 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int get_create_wall ()"

.PP
\fBSee also\fP
.RS 4
\fBget_create_vwall\fP
.RE
.PP
Reports if the Create sees a physical wall\&. 
.PP
\fBNote\fP
.RS 4
The Create only detects walls on the right because Roombas only need it on the right side\&. 
.RE
.PP

.SS "\fBEXPORT_SYM\fP int get_create_wall_amt ()"
Returns the wall signal sensed by the create\&. 
.PP
\fBSee also\fP
.RS 4
\fBget_create_wall\fP 
.RE
.PP

.SS "bool kipr::create::Create::loadSong (const unsigned char * song, const unsigned char length, const unsigned char songNum)"
Loads a song for playing on the create 
.PP
\fBParameters\fP
.RS 4
\fIsong\fP It should be an array of unsigned chars (positive integers 0-255) The first value in a pair will be the midi value of the note the second value in the pair will be the duration (in 64ths of a second) for example, a song {88, 20, 91, 32, 70, 15} will play midi value 88 for 20/64ths of a second, midi value 91 for 32/64ths of a second, and midi value 70 for 15/64ths of a second\&. A full list of notes playable on the create is found at https://cdn-shop.adafruit.com/datasheets/create_2_Open_Interface_Spec.pdf on page 34 
.br
\fIlength\fP The length of the song\&. It is how many notes are in the song, not how many items are in your song array\&. 
.br
\fInum\fP The song slot to load the song into; valid values are 0, 1, 2, and 3 
.RE
.PP
\fBReturns\fP
.RS 4
1 on success, 0 on failure 
.RE
.PP
\fBNote\fP
.RS 4
Example use: \fCunsigned char example_song[] = {88, 20, 91, 32, 70, 15}; create_load_song(example_song, 3, 0);\fP 
.RE
.PP

.SS "bool kipr::create::Create::playSong (const unsigned char songNum)"
Plays a song that has been loaded\&. Use create_load_song first\&. 
.PP
\fBParameters\fP
.RS 4
\fInum\fP The song slot to play from; valid values are 0, 1, 2, and 3 
.RE
.PP
\fBReturns\fP
.RS 4
1 on success, 0 on failure 
.RE
.PP
\fBSee also\fP
.RS 4
\fBcreate_load_song\fP 
.RE
.PP

.SS "\fBEXPORT_SYM\fP void set_create_baud_rate (const enum \fBBaudRate\fP baudRate)"
Sets the create's baud rate to the provided baud rate\&. 
.SS "\fBEXPORT_SYM\fP void set_create_distance (int dist)"
Sets the current distance the create thinks it has traveled\&.
.PP
Use this to set it's reference for where it is\&. 
.SS "\fBEXPORT_SYM\fP void set_create_normalized_angle (int angle)"

.PP
\fBSee also\fP
.RS 4
\fBget_create_normalized_angle\fP
.RE
.PP
Set the current angle that the create is at\&.
.PP
Sets what the create should use as a reference for its angle 
.SS "\fBEXPORT_SYM\fP void set_create_total_angle (int angle)"

.PP
\fBSee also\fP
.RS 4
\fBget_create_total_angle\fP
.RE
.PP
Set the current angle that the create is at for the total angle functions\&.
.PP
Sets what the create should use as a reference for its angle 
.SH "Author"
.PP 
Generated automatically by Doxygen for libkipr from the source code\&.
